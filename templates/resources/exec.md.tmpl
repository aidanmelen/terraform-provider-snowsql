---
page_title: "{{.Name}} {{.Type}} - {{.ProviderName}}"
subcategory: ""
description: |-
{{ .Description | plainmarkdown | trimspace | prefixlines "  " }}
---

# {{.Name}} ({{.Type}})

{{ .Description | trimspace }}

## Example Basic Usage

{{ tffile "examples/resources/exec/basic/main.tf" }}

## Example Multi-Statement Usage

{{ tffile "examples/resources/exec/complete/main.tf" }}

## Avoiding Replacement

Any changes to the `create` statements will cause a replacement change. Adding or changing the `update` statements will result in an in-place change with the execution of the `update` statement.

1. The `create` statements are run on the first apply:

    ```terraform
    resource "snowsql_exec" "role" {
      name = "my_role"

      create {
        statements = "CREATE ROLE IF NOT EXISTS my_role;"
      }

      read {
        statements = "SHOW ROLES LIKE 'my_role';"
      }

      delete {
        statements = "DROP ROLE IF EXISTS my_role;"
      }
    }
    ```

2. Add the `update` statements to alter the role in-place.

    ```terraform
    resource "snowsql_exec" "role" {
      name = "my_role"

      create {
        statements = "CREATE ROLE IF NOT EXISTS my_role;"
      }

      read {
        statements = "SHOW ROLES LIKE 'my_role';"
      }

      update {
        statements = "ALTER ROLE IF EXISTS my_role SET COMMENT = 'updated with terraform';"
      }

      delete {
        statements = "DROP ROLE IF EXISTS my_role;"
      }
    }
    ```

    **NOTE** the `create` statements are only executed on creation or when the statements change.

## Continuous Updates

Use the [The lifecycle Meta-Argument](https://developer.hashicorp.com/terraform/language/meta-arguments/lifecycle#ignore_changes) to ignore changes to the create statements.

```terraform
resource "snowflake_database" "database" {
  name = "my_database"
}

resource "snowflake_schema" "schema" {
  name     = "my_schema"
  database = snowflake_database.database.name
}

resource "snowflake_table" "target_table" {
  name     = "target_table"
  database = snowflake_database.database.name
  schema   = snowflake_schema.schema.name

  column {
    name = "id"
    type = "INTEGER"
  }

  column {
    name = "description"
    type = "VARCHAR"
  }
}

resource "snowflake_table" "source_table" {
  name     = "source_table"
  database = snowflake_database.database.name
  schema   = snowflake_schema.schema.name

  column {
    name = "id"
    type = "INTEGER"
  }

  column {
    name = "description"
    type = "VARCHAR"
  }
}

locals {
  merge_create_and_update = <<-EOT
    MERGE INTO target_table USING source_table 
        ON target_table.id = source_table.id
        WHEN MATCHED THEN 
            UPDATE SET target_table.description = source_table.description;
  EOT
}

resource "snowsql_exec" "merge" {
  name = "my_merge"

  create {
    statements = local.merge_create_and_update
  }

  read {
    statements = <<-EOT
      SELECT * FROM target_table;
      SELECT * FROM source_table;
  }

  update {
    statements = local.merge_create_and_update

  delete {
    statements = "DROP ROLE IF EXISTS my_role;"
  }

  lifecycle {
    ignore_changes = [
      # Ignore changes to create, e.g. because create statement changes
      # cause a forced replacement.
      create,
    ]
  }
}
```

{{ .SchemaMarkdown | trimspace }}

## Import

Import is supported using the following syntax:

```shell
terraform import snowsql_exec.name name
```